#include <stdint.h>
#include "Encoder.h"
#include "StateMap.h"
#include "Mixer.h"
#include "HashTable.h"
#include "MatchModel.h"

int MEM = 0;
static uint8_t t0[0x10000];
static struct HashTable ht;
static int c4 = 0;
static uint8_t *cp[6] = { t0, t0, t0, t0, t0, t0 };
static int bcount = 0;
static struct StateMap sm[6];
static struct APM a1, a2;
static uint32_t h[6];
static struct Mixer m;
static struct MatchModel mm;

static const uint8_t State_table[256][2]={
{  1,  2},{  3,  5},{  4,  6},{  7, 10},{  8, 12},{  9, 13},{ 11, 14}, // 0
{ 15, 19},{ 16, 23},{ 17, 24},{ 18, 25},{ 20, 27},{ 21, 28},{ 22, 29}, // 7
{ 26, 30},{ 31, 33},{ 32, 35},{ 32, 35},{ 32, 35},{ 32, 35},{ 34, 37}, // 14
{ 34, 37},{ 34, 37},{ 34, 37},{ 34, 37},{ 34, 37},{ 36, 39},{ 36, 39}, // 21
{ 36, 39},{ 36, 39},{ 38, 40},{ 41, 43},{ 42, 45},{ 42, 45},{ 44, 47}, // 28
{ 44, 47},{ 46, 49},{ 46, 49},{ 48, 51},{ 48, 51},{ 50, 52},{ 53, 43}, // 35
{ 54, 57},{ 54, 57},{ 56, 59},{ 56, 59},{ 58, 61},{ 58, 61},{ 60, 63}, // 42
{ 60, 63},{ 62, 65},{ 62, 65},{ 50, 66},{ 67, 55},{ 68, 57},{ 68, 57}, // 49
{ 70, 73},{ 70, 73},{ 72, 75},{ 72, 75},{ 74, 77},{ 74, 77},{ 76, 79}, // 56
{ 76, 79},{ 62, 81},{ 62, 81},{ 64, 82},{ 83, 69},{ 84, 71},{ 84, 71}, // 63
{ 86, 73},{ 86, 73},{ 44, 59},{ 44, 59},{ 58, 61},{ 58, 61},{ 60, 49}, // 70
{ 60, 49},{ 76, 89},{ 76, 89},{ 78, 91},{ 78, 91},{ 80, 92},{ 93, 69}, // 77
{ 94, 87},{ 94, 87},{ 96, 45},{ 96, 45},{ 48, 99},{ 48, 99},{ 88,101}, // 84
{ 88,101},{ 80,102},{103, 69},{104, 87},{104, 87},{106, 57},{106, 57}, // 91
{ 62,109},{ 62,109},{ 88,111},{ 88,111},{ 80,112},{113, 85},{114, 87}, // 98
{114, 87},{116, 57},{116, 57},{ 62,119},{ 62,119},{ 88,121},{ 88,121}, // 105
{ 90,122},{123, 85},{124, 97},{124, 97},{126, 57},{126, 57},{ 62,129}, // 112
{ 62,129},{ 98,131},{ 98,131},{ 90,132},{133, 85},{134, 97},{134, 97}, // 119
{136, 57},{136, 57},{ 62,139},{ 62,139},{ 98,141},{ 98,141},{ 90,142}, // 126
{143, 95},{144, 97},{144, 97},{ 68, 57},{ 68, 57},{ 62, 81},{ 62, 81}, // 133
{ 98,147},{ 98,147},{100,148},{149, 95},{150,107},{150,107},{108,151}, // 140
{108,151},{100,152},{153, 95},{154,107},{108,155},{100,156},{157, 95}, // 147
{158,107},{108,159},{100,160},{161,105},{162,107},{108,163},{110,164}, // 154
{165,105},{166,117},{118,167},{110,168},{169,105},{170,117},{118,171}, // 161
{110,172},{173,105},{174,117},{118,175},{110,176},{177,105},{178,117}, // 168
{118,179},{110,180},{181,115},{182,117},{118,183},{120,184},{185,115}, // 175
{186,127},{128,187},{120,188},{189,115},{190,127},{128,191},{120,192}, // 182
{193,115},{194,127},{128,195},{120,196},{197,115},{198,127},{128,199}, // 189
{120,200},{201,115},{202,127},{128,203},{120,204},{205,115},{206,127}, // 196
{128,207},{120,208},{209,125},{210,127},{128,211},{130,212},{213,125}, // 203
{214,137},{138,215},{130,216},{217,125},{218,137},{138,219},{130,220}, // 210
{221,125},{222,137},{138,223},{130,224},{225,125},{226,137},{138,227}, // 217
{130,228},{229,125},{230,137},{138,231},{130,232},{233,125},{234,137}, // 224
{138,235},{130,236},{237,125},{238,137},{138,239},{130,240},{241,125}, // 231
{242,137},{138,243},{130,244},{245,135},{246,137},{138,247},{140,248}, // 238
{249,135},{250, 69},{ 80,251},{140,252},{249,135},{250, 69},{ 80,251}, // 245
{140,252},{  0,  0},{  0,  0},{  0,  0}};  // 252
#define nex(state,sel) State_table[state][sel]

static int update(int y)
{
	*cp[0] = nex(*cp[0], y);
	*cp[1] = nex(*cp[1], y);
	*cp[2] = nex(*cp[2], y);
	*cp[3] = nex(*cp[3], y);
	*cp[4] = nex(*cp[4], y);
	*cp[5] = nex(*cp[5], y);
	m.update(&m, y);
	c0 += c0 + y;
	if (c0 >= 256) {
		h1 = (h1 * (3 << 3) + c0) & HN;
		h2 = (h2 * (5 << 5) + c0) & HN;
		buf[pos++] = c0;
		pos &= N;
		c0 -= 256;
		c4 = c4 << 8 | c0;
		h[0] = c0 << 8;
		h[1] = (c4 & 0xffff) << 5 | 0x57000000;
		h[2] = (c4 << 8) * 3;
		h[3] = c4 * 5;
		h[4] = h[4] * (11 << 5) + c0 * 13 & 0x3fffffff;
		if (c0 >= 65 && c0 <= 90)
			c0 += 32;
		if (c0 >= 97 && c0 <= 122)
			h[5] = (h[5] + c0) * (7 << 3);
		else
			h[5] = 0;
		cp[1] = t(&ht, h[1]) + 1;
		cp[2] = t(&ht, h[2]) + 1;
		cp[3] = t(&ht, h[3]) + 1;
		cp[4] = t(&ht, h[4]) + 1;
		cp[5] = t(&ht, h[5]) + 1;
		c0 = 1;
		bcount = 0;
	} else {
		++bcount;
		if (bcount == 4) {
			cp[1] = t(&ht, h[1] + c0) + 1;
			cp[2] = t(&ht, h[2] + c0) + 1;
			cp[3] = t(&ht, h[3] + c0) + 1;
			cp[4] = t(&ht, h[4] + c0) + 1;
			cp[5] = t(&ht, h[5] + c0) + 1;
		} else {
			int j = y + 1 << (bcount & 3) - 1;
			cp[1] += j;
			cp[2] += j;
			cp[3] += j;
			cp[4] += j;
			cp[5] += j;
		}
	}
	cp[0] = t0 + h[0] + c0;
	int y22 = y << 22, len = mm.p(&mm, y22), order;
	if (len == 0)
		order = (*cp[1] != 0) + (*cp[2] != 0) + (*cp[3] != 0) + (*cp[4] != 0);
	else
		order = 5 + (len >= 8) + (len >= 12) + (len >= 16) + (len >= 32);
	m_add(1, sm[0].p(&sm[0], y22, *cp[0], 1023));
	m_add(2, sm[1].p(&sm[1], y22, *cp[1], 1023));
	m_add(3, sm[2].p(&sm[2], y22, *cp[2], 1023));
	m_add(4, sm[3].p(&sm[3], y22, *cp[3], 1023));
	m_add(5, sm[4].p(&sm[4], y22, *cp[4], 1023));
	m_add(6, sm[5].p(&sm[5], y22, *cp[5], 1023));
	m.set(&m, order + 10 * (h[0] >> 13));
	int pr = m.p(&m);
	pr = pr + 3 * a1.pp(&a1, y22, pr, c0, 255) >> 2;
	pr = pr + 3 * a2.pp(&a2, y22, pr, c0 ^ h[0] >> 2, 255) >> 2;
	return pr;
}

static int code(struct Encoder *e, int y)
{
	int p = e->pr;
	p += p < 2048;
	uint32_t xmid = e->x1 + (e->x2 - e->x1 >> 12) * p + ((e->x2 - e->x1 & 0xfff) * p >> 12);
	if (e->mode == DECOMPRESS)
		y = e->x <= xmid;
	y ? (e->x2 = xmid) : (e->x1 = xmid + 1);
	e->pr = update(y);
	while (((e->x1 ^ e->x2) & 0xff000000) == 0) {
		if (e->mode == COMPRESS)
			putc(e->x2 >> 24, e->archive);
		e->x1 <<= 8;
		e->x2 = (e->x2 << 8) + 255;
		if (e->mode == DECOMPRESS)
			e->x = (e->x << 8) + (getc(e->archive) & 255);
	}
	return y;
}

static void compress(struct Encoder *e, int c)
{
	for (int i = 7; i >= 0; --i)
		code(e, (c >> i) & 1);
}

static int decompress(struct Encoder *e)
{
	int c = 0;
	for (int i = 0; i < 8; ++i)
		c += c + code(e, 0);
	return c;
}

static void flush(struct Encoder *e)
{
	if (e->mode == COMPRESS)
		putc(e->x1 >> 24, e->archive);
}

void Encoder(struct Encoder *e, Mode md, FILE *f)
{
	e->pr = 2048;
	e->archive = f;
	e->x1 = 0;
	e->x2 = 0xffffffff;
	e->x = 0;
	if ((e->mode = md) != COMPRESS)
		for (int i = 0; i < 4; ++i)
			e->x = (e->x << 8) + (getc(e->archive) & 255);
	e->compress = compress;
	e->flush = flush;
	e->decompress = decompress;
	HashTable(&ht, 16, MEM * 2);
	StateMap(&sm[0], 256);
	StateMap(&sm[1], 256);
	StateMap(&sm[2], 256);
	StateMap(&sm[3], 256);
	StateMap(&sm[4], 256);
	StateMap(&sm[5], 256);
	APM(&a1, 0x100);
	APM(&a2, 0x4000);
	Mixer(&m, 80, 7);
	MatchModel(&mm, MEM);
	int pi = 0;
	for (int x = -2047; x <= 2047; ++x) {
		int i = squash(x);
		for (int j = pi; j <= i; ++j)
			stretch_t[j] = x;
		pi = i + 1;
	}
	stretch_t[4095] = 2047;
	for (int i = 0; i < 1024; ++i)
		dt[i] = 16384 / (i + i + 3);
}
